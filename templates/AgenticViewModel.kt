package com.example.app.ui.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.app.ai.AIService
import com.example.app.ai.ChatMessage
import com.example.app.ai.FunctionCall
import com.example.app.functions.FunctionExecutor
import com.example.app.functions.FunctionRegistry
import com.example.app.functions.FunctionResult
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * Enhanced ViewModel with Function Calling
 * Auto-generated by CodeCraft AI
 */

@HiltViewModel
class AgenticChatViewModel @Inject constructor(
    private val aiService: AIService,
    private val functionExecutor: FunctionExecutor,
    private val functionRegistry: FunctionRegistry
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(AgenticChatUiState())
    val uiState: StateFlow<AgenticChatUiState> = _uiState.asStateFlow()
    
    fun sendMessage(userMessage: String) {
        viewModelScope.launch {
            // Add user message
            val userChatMessage = ChatMessage(role = "user", content = userMessage)
            addMessage(userChatMessage)
            
            setLoading(true)
            
            try {
                // Send to Gemini with available tools
                val response = aiService.chatWithTools(
                    message = userMessage,
                    tools = functionRegistry.getAllFunctions(),
                    conversationHistory = _uiState.value.messages
                ).getOrThrow()
                
                when {
                    response.hasFunctionCall() -> {
                        handleFunctionCalls(response.functionCalls)
                    }
                    else -> {
                        addMessage(ChatMessage(role = "assistant", content = response.text))
                    }
                }
            } catch (e: Exception) {
                addMessage(ChatMessage(
                    role = "assistant", 
                    content = "❌ Error: ${e.message}"
                ))
            } finally {
                setLoading(false)
            }
        }
    }
    
    private suspend fun handleFunctionCalls(functionCalls: List<FunctionCall>) {
        val results = mutableListOf<FunctionResult>()
        
        // Execute each function call
        functionCalls.forEach { call ->
            // Show function call in UI
            addFunctionCall(call)
            
            try {
                val result = functionExecutor.execute(
                    functionName = call.name,
                    parameters = call.args,
                    userId = getCurrentUserId()
                ).getOrThrow()
                
                results.add(result)
                updateFunctionResult(call, result)
                
            } catch (e: Exception) {
                val errorResult = FunctionResult(
                    functionName = call.name,
                    data = "Error",
                    summary = "❌ ${e.message}"
                )
                results.add(errorResult)
                updateFunctionResult(call, errorResult)
            }
        }
        
        // Send results back to Gemini for final response
        generateFinalResponse(results)
    }
    
    private suspend fun generateFinalResponse(results: List<FunctionResult>) {
        val resultsContext = results.joinToString("\\n") { 
            "${it.functionName}: ${it.summary}" 
        }
        
        try {
            val finalResponse = aiService.chatWithTools(
                message = "Based on these function results, provide a helpful summary:\\n$resultsContext",
                tools = emptyList(), // No more function calls needed
                conversationHistory = _uiState.value.messages
            ).getOrThrow()
            
            addMessage(ChatMessage(role = "assistant", content = finalResponse.text))
        } catch (e: Exception) {
            addMessage(ChatMessage(
                role = "assistant",
                content = "✅ Functions executed successfully:\\n${results.joinToString("\\n") { "• ${it.summary}" }}"
            ))
        }
    }
    
    private fun addMessage(message: ChatMessage) {
        _uiState.update { state ->
            state.copy(messages = state.messages + message)
        }
    }
    
    private fun addFunctionCall(call: FunctionCall) {
        _uiState.update { state ->
            state.copy(
                activeFunctionCalls = state.activeFunctionCalls + 
                    FunctionCallState(call = call, result = null, isExecuting = true)
            )
        }
    }
    
    private fun updateFunctionResult(call: FunctionCall, result: FunctionResult) {
        _uiState.update { state ->
            state.copy(
                activeFunctionCalls = state.activeFunctionCalls.map { callState ->
                    if (callState.call.name == call.name) {
                        callState.copy(result = result, isExecuting = false)
                    } else callState
                }
            )
        }
    }
    
    private fun setLoading(isLoading: Boolean) {
        _uiState.update { it.copy(isLoading = isLoading) }
    }
    
    private fun getCurrentUserId(): String? {
        // In real app, get from auth repository
        return "user123"
    }
    
    fun clearFunctionCalls() {
        _uiState.update { it.copy(activeFunctionCalls = emptyList()) }
    }
}

data class AgenticChatUiState(
    val messages: List<ChatMessage> = emptyList(),
    val activeFunctionCalls: List<FunctionCallState> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
)

data class FunctionCallState(
    val call: FunctionCall,
    val result: FunctionResult?,
    val isExecuting: Boolean
)