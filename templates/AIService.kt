package com.example.app.ai

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import org.json.JSONArray
import java.io.IOException

/**
 * AI Service - Gemini API with Function Calling
 * Auto-generated by CodeCraft AI
 */
class AIService(private val apiKey: String = "YOUR_GEMINI_API_KEY") {
    
    private val client = OkHttpClient()
    private val baseUrl = "https://generativelanguage.googleapis.com/v1beta/models"
    private val model = "gemini-pro"
    
    /**
     * Chat with Function Calling Support
     */
    suspend fun chatWithTools(
        message: String,
        tools: List<FunctionDefinition>,
        conversationHistory: List<ChatMessage> = emptyList()
    ): Result<GeminiResponse> = withContext(Dispatchers.IO) {
        try {
            val json = JSONObject().apply {
                put("contents", buildContents(message, conversationHistory))
                if (tools.isNotEmpty()) {
                    put("tools", JSONArray().apply {
                        put(JSONObject().apply {
                            put("function_declarations", JSONArray().apply {
                                tools.forEach { tool ->
                                    put(tool.toGeminiFunction())
                                }
                            })
                        })
                    })
                }
            }
            
            val request = Request.Builder()
                .url("$baseUrl/$model:generateContent?key=$apiKey")
                .post(json.toString().toRequestBody("application/json".toMediaType()))
                .build()
            
            val response = client.newCall(request).execute()
            
            if (response.isSuccessful) {
                val result = parseGeminiResponse(response.body?.string())
                Result.success(result)
            } else {
                Result.failure(Exception("API Error: ${response.code}"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private fun buildContents(message: String, history: List<ChatMessage>): JSONArray {
        return JSONArray().apply {
            history.forEach { msg ->
                put(JSONObject().apply {
                    put("role", msg.role)
                    put("parts", JSONArray().apply {
                        put(JSONObject().put("text", msg.content))
                    })
                })
            }
            put(JSONObject().apply {
                put("role", "user")
                put("parts", JSONArray().apply {
                    put(JSONObject().put("text", message))
                })
            })
        }
    }
    
    private fun parseGeminiResponse(responseBody: String?): GeminiResponse {
        return try {
            val json = JSONObject(responseBody ?: "")
            val candidate = json.getJSONArray("candidates").getJSONObject(0)
            val content = candidate.getJSONObject("content")
            val parts = content.getJSONArray("parts")
            
            val functionCalls = mutableListOf<FunctionCall>()
            var textResponse = ""
            
            for (i in 0 until parts.length()) {
                val part = parts.getJSONObject(i)
                
                when {
                    part.has("function_call") -> {
                        val funcCall = part.getJSONObject("function_call")
                        functionCalls.add(
                            FunctionCall(
                                name = funcCall.getString("name"),
                                args = funcCall.getJSONObject("args").toMap()
                            )
                        )
                    }
                    part.has("text") -> {
                        textResponse = part.getString("text")
                    }
                }
            }
            
            GeminiResponse(
                text = textResponse,
                functionCalls = functionCalls
            )
        } catch (e: Exception) {
            GeminiResponse(text = "Error parsing response", functionCalls = emptyList())
        }
    }
    
    /**
     * Generate text response from AI
     */
    suspend fun generateText(prompt: String): Result<String> = withContext(Dispatchers.IO) {
        try {
            val json = JSONObject().apply {
                put("contents", JSONArray().apply {
                    put(JSONObject().apply {
                        put("parts", JSONArray().apply {
                            put(JSONObject().put("text", prompt))
                        })
                    })
                })
            }
            
            val request = Request.Builder()
                .url("$baseUrl/$model:generateContent?key=$apiKey")
                .post(json.toString().toRequestBody("application/json".toMediaType()))
                .build()
            
            val response = client.newCall(request).execute()
            
            if (response.isSuccessful) {
                val responseBody = response.body?.string()
                val result = parseResponse(responseBody)
                Result.success(result)
            } else {
                Result.failure(Exception("API Error: ${response.code}"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Chat with AI (maintains context)
     */
    suspend fun chat(messages: List<ChatMessage>): Result<String> = withContext(Dispatchers.IO) {
        try {
            val json = JSONObject().apply {
                put("contents", JSONArray().apply {
                    messages.forEach { msg ->
                        put(JSONObject().apply {
                            put("role", msg.role)
                            put("parts", JSONArray().apply {
                                put(JSONObject().put("text", msg.content))
                            })
                        })
                    }
                })
            }
            
            val request = Request.Builder()
                .url("$baseUrl/$model:generateContent?key=$apiKey")
                .post(json.toString().toRequestBody("application/json".toMediaType()))
                .build()
            
            val response = client.newCall(request).execute()
            
            if (response.isSuccessful) {
                val result = parseResponse(response.body?.string())
                Result.success(result)
            } else {
                Result.failure(Exception("Chat Error: ${response.code}"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Analyze image with AI
     */
    suspend fun analyzeImage(imageBase64: String, prompt: String): Result<String> = 
        withContext(Dispatchers.IO) {
            try {
                val json = JSONObject().apply {
                    put("contents", JSONArray().apply {
                        put(JSONObject().apply {
                            put("parts", JSONArray().apply {
                                put(JSONObject().put("text", prompt))
                                put(JSONObject().apply {
                                    put("inline_data", JSONObject().apply {
                                        put("mime_type", "image/jpeg")
                                        put("data", imageBase64)
                                    })
                                })
                            })
                        })
                    })
                }
                
                val request = Request.Builder()
                    .url("$baseUrl/gemini-pro-vision:generateContent?key=$apiKey")
                    .post(json.toString().toRequestBody("application/json".toMediaType()))
                    .build()
                
                val response = client.newCall(request).execute()
                
                if (response.isSuccessful) {
                    val result = parseResponse(response.body?.string())
                    Result.success(result)
                } else {
                    Result.failure(Exception("Vision Error: ${response.code}"))
                }
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    
    private fun parseResponse(responseBody: String?): String {
        return try {
            val json = JSONObject(responseBody ?: "")
            json.getJSONArray("candidates")
                .getJSONObject(0)
                .getJSONObject("content")
                .getJSONArray("parts")
                .getJSONObject(0)
                .getString("text")
        } catch (e: Exception) {
            "Error parsing response"
        }
}

// Data Classes for Function Calling
data class FunctionDefinition(
    val name: String,
    val description: String,
    val parameters: Map<String, ParameterSchema>,
    val requiresAuth: Boolean = false,
    val riskLevel: RiskLevel = RiskLevel.SAFE
) {
    fun toGeminiFunction(): JSONObject {
        return JSONObject().apply {
            put("name", name)
            put("description", description)
            put("parameters", JSONObject().apply {
                put("type", "object")
                put("properties", JSONObject().apply {
                    parameters.forEach { (key, schema) ->
                        put(key, JSONObject().apply {
                            put("type", schema.type)
                            put("description", schema.description)
                        })
                    }
                })
                put("required", JSONArray().apply {
                    parameters.filter { it.value.required }.keys.forEach { put(it) }
                })
            })
        }
    }
}

data class ParameterSchema(
    val type: String,
    val description: String,
    val required: Boolean = true
)

enum class RiskLevel {
    SAFE, MODERATE, CRITICAL
}

data class FunctionCall(
    val name: String,
    val args: Map<String, Any>
)

data class GeminiResponse(
    val text: String,
    val functionCalls: List<FunctionCall>
) {
    fun hasFunctionCall() = functionCalls.isNotEmpty()
}

// Extension function
fun JSONObject.toMap(): Map<String, Any> {
    val map = mutableMapOf<String, Any>()
    keys().forEach { key ->
        map[key] = get(key)
    }
    return map
}
