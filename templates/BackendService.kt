package com.example.app.backend

import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.ktx.firestore
import com.google.firebase.ktx.Firebase
import kotlinx.coroutines.tasks.await

/**
 * Firebase Backend Service
 * Auto-generated by CodeCraft AI
 */
class FirebaseBackend {
    
    private val auth = FirebaseAuth.getInstance()
    private val db = Firebase.firestore
    
    // ============================================================================
    // AUTHENTICATION
    // ============================================================================
    
    suspend fun signUp(email: String, password: String): Result<String> {
        return try {
            val result = auth.createUserWithEmailAndPassword(email, password).await()
            Result.success(result.user?.uid ?: "")
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun signIn(email: String, password: String): Result<String> {
        return try {
            val result = auth.signInWithEmailAndPassword(email, password).await()
            Result.success(result.user?.uid ?: "")
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    fun signOut() = auth.signOut()
    
    fun getCurrentUserId() = auth.currentUser?.uid
    
    // ============================================================================
    // FIRESTORE OPERATIONS
    // ============================================================================
    
    suspend fun <T> saveData(collection: String, documentId: String, data: T): Result<Unit> {
        return try {
            db.collection(collection).document(documentId).set(data as Any).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun <T> getData(collection: String, documentId: String, clazz: Class<T>): Result<T?> {
        return try {
            val doc = db.collection(collection).document(documentId).get().await()
            Result.success(doc.toObject(clazz))
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun <T> getCollection(collection: String, clazz: Class<T>): Result<List<T>> {
        return try {
            val snapshot = db.collection(collection).get().await()
            val items = snapshot.documents.mapNotNull { it.toObject(clazz) }
            Result.success(items)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun deleteData(collection: String, documentId: String): Result<Unit> {
        return try {
            db.collection(collection).document(documentId).delete().await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    // ============================================================================
    // REAL-TIME LISTENERS
    // ============================================================================
    
    fun <T> listenToDocument(
        collection: String,
        documentId: String,
        clazz: Class<T>,
        onUpdate: (T?) -> Unit
    ) {
        db.collection(collection).document(documentId)
            .addSnapshotListener { snapshot, error ->
                if (error != null) return@addSnapshotListener
                onUpdate(snapshot?.toObject(clazz))
            }
    }
    
    fun <T> listenToCollection(
        collection: String,
        clazz: Class<T>,
        onUpdate: (List<T>) -> Unit
    ) {
        db.collection(collection)
            .addSnapshotListener { snapshot, error ->
                if (error != null) return@addSnapshotListener
                val items = snapshot?.documents?.mapNotNull { it.toObject(clazz) } ?: emptyList()
                onUpdate(items)
            }
    }
}

/**
 * Supabase Backend Service (Alternative)
 */
class SupabaseBackend(
    private val supabaseUrl: String = "YOUR_SUPABASE_URL",
    private val supabaseKey: String = "YOUR_SUPABASE_KEY"
) {
    
    private val client = okhttp3.OkHttpClient()
    
    suspend fun signUp(email: String, password: String): Result<String> {
        return try {
            val json = org.json.JSONObject().apply {
                put("email", email)
                put("password", password)
            }
            
            val request = okhttp3.Request.Builder()
                .url("$supabaseUrl/auth/v1/signup")
                .post(json.toString().toRequestBody("application/json".toMediaType()))
                .addHeader("apikey", supabaseKey)
                .build()
            
            val response = client.newCall(request).execute()
            if (response.isSuccessful) {
                val userId = org.json.JSONObject(response.body?.string() ?: "")
                    .getJSONObject("user")
                    .getString("id")
                Result.success(userId)
            } else {
                Result.failure(Exception("Signup failed"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun <T> insert(table: String, data: T): Result<Unit> {
        return try {
            val json = com.google.gson.Gson().toJson(data)
            
            val request = okhttp3.Request.Builder()
                .url("$supabaseUrl/rest/v1/$table")
                .post(json.toRequestBody("application/json".toMediaType()))
                .addHeader("apikey", supabaseKey)
                .addHeader("Prefer", "return=minimal")
                .build()
            
            val response = client.newCall(request).execute()
            if (response.isSuccessful) {
                Result.success(Unit)
            } else {
                Result.failure(Exception("Insert failed"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun <T> select(table: String, clazz: Class<T>): Result<List<T>> {
        return try {
            val request = okhttp3.Request.Builder()
                .url("$supabaseUrl/rest/v1/$table?select=*")
                .get()
                .addHeader("apikey", supabaseKey)
                .build()
            
            val response = client.newCall(request).execute()
            if (response.isSuccessful) {
                val json = response.body?.string() ?: "[]"
                val items = com.google.gson.Gson().fromJson(json, 
                    com.google.gson.reflect.TypeToken.getParameterized(List::class.java, clazz).type
                ) as List<T>
                Result.success(items)
            } else {
                Result.failure(Exception("Select failed"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

// Extension for easy usage
fun okhttp3.RequestBody.Companion.toRequestBody(content: String, mediaType: okhttp3.MediaType) =
    content.toRequestBody(mediaType)
