package com.example.app.functions

import com.example.app.ai.FunctionDefinition
import com.example.app.ai.ParameterSchema
import com.example.app.ai.RiskLevel
import com.example.app.backend.FirebaseBackend
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Function Registry & Executor - Agentic Workflow
 * Auto-generated by CodeCraft AI
 */

@Singleton
class FunctionRegistry @Inject constructor() {
    
    private val functions = mutableMapOf<String, FunctionDefinition>()

    init {
        registerCoreFunctions()
    }

    private fun registerCoreFunctions() {
        // Data Operations
        register(FunctionDefinition(
            name = "save_note",
            description = "Save a note to user's notebook",
            parameters = mapOf(
                "title" to ParameterSchema("string", "Note title"),
                "content" to ParameterSchema("string", "Note content")
            ),
            requiresAuth = true,
            riskLevel = RiskLevel.MODERATE
        ))
        
        register(FunctionDefinition(
            name = "get_notes",
            description = "Retrieve user's saved notes",
            parameters = mapOf(
                "limit" to ParameterSchema("number", "Number of notes to retrieve", false)
            ),
            requiresAuth = true,
            riskLevel = RiskLevel.SAFE
        ))
        
        // Calculations
        register(FunctionDefinition(
            name = "calculate",
            description = "Perform mathematical calculations",
            parameters = mapOf(
                "expression" to ParameterSchema("string", "Mathematical expression to calculate")
            ),
            riskLevel = RiskLevel.SAFE
        ))
        
        // System Operations
        register(FunctionDefinition(
            name = "get_weather",
            description = "Get current weather information",
            parameters = mapOf(
                "city" to ParameterSchema("string", "City name")
            ),
            riskLevel = RiskLevel.SAFE
        ))
    }

    fun register(function: FunctionDefinition) {
        functions[function.name] = function
    }

    fun get(name: String) = functions[name]
    
    fun getAllFunctions() = functions.values.toList()
}

@Singleton
class FunctionExecutor @Inject constructor(
    private val backendService: FirebaseBackend,
    private val functionRegistry: FunctionRegistry
) {
    
    suspend fun execute(
        functionName: String,
        parameters: Map<String, Any>,
        userId: String? = null
    ): Result<FunctionResult> = withContext(Dispatchers.IO) {
        try {
            val function = functionRegistry.get(functionName)
                ?: return@withContext Result.failure(
                    Exception("Unknown function: $functionName")
                )

            // Security check
            if (function.requiresAuth && userId == null) {
                return@withContext Result.failure(
                    Exception("Authentication required for $functionName")
                )
            }

            // Parameter validation
            validateParameters(function.parameters, parameters)

            // Execute function
            val result = when (functionName) {
                "save_note" -> executeSaveNote(parameters, userId!!)
                "get_notes" -> executeGetNotes(parameters, userId!!)
                "calculate" -> executeCalculate(parameters)
                "get_weather" -> executeGetWeather(parameters)
                else -> throw IllegalArgumentException("Unimplemented function: $functionName")
            }

            Result.success(result)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private fun validateParameters(
        schema: Map<String, ParameterSchema>,
        params: Map<String, Any>
    ) {
        schema.forEach { (key, paramSchema) ->
            if (paramSchema.required && !params.containsKey(key)) {
                throw IllegalArgumentException("Missing required parameter: $key")
            }
        }
    }
    
    private suspend fun executeSaveNote(
        params: Map<String, Any>,
        userId: String
    ): FunctionResult {
        val title = params["title"] as String
        val content = params["content"] as String
        
        val note = Note(
            id = System.currentTimeMillis().toString(),
            title = title,
            content = content,
            userId = userId,
            timestamp = System.currentTimeMillis()
        )
        
        backendService.saveData("notes", note.id, note)
        
        return FunctionResult(
            functionName = "save_note",
            data = note,
            summary = "‚úÖ Note '$title' saved successfully"
        )
    }
    
    private suspend fun executeGetNotes(
        params: Map<String, Any>,
        userId: String
    ): FunctionResult {
        val limit = (params["limit"] as? Double)?.toInt() ?: 10
        
        // Simulate getting user notes
        val notes = listOf(
            Note("1", "Meeting Notes", "Discussed project timeline", userId, System.currentTimeMillis()),
            Note("2", "Shopping List", "Milk, Bread, Eggs", userId, System.currentTimeMillis() - 86400000)
        ).take(limit)
        
        return FunctionResult(
            functionName = "get_notes",
            data = notes,
            summary = "üìù Retrieved ${notes.size} notes"
        )
    }
    
    private fun executeCalculate(params: Map<String, Any>): FunctionResult {
        val expression = params["expression"] as String
        
        // Simple calculator (in real app, use proper math parser)
        val result = try {
            when {
                "+" in expression -> {
                    val parts = expression.split("+")
                    parts.sumOf { it.trim().toDouble() }
                }
                "-" in expression -> {
                    val parts = expression.split("-")
                    parts[0].trim().toDouble() - parts[1].trim().toDouble()
                }
                "*" in expression -> {
                    val parts = expression.split("*")
                    parts.fold(1.0) { acc, part -> acc * part.trim().toDouble() }
                }
                "/" in expression -> {
                    val parts = expression.split("/")
                    parts[0].trim().toDouble() / parts[1].trim().toDouble()
                }
                else -> expression.toDouble()
            }
        } catch (e: Exception) {
            throw IllegalArgumentException("Invalid mathematical expression: $expression")
        }
        
        return FunctionResult(
            functionName = "calculate",
            data = result,
            summary = "üßÆ $expression = $result"
        )
    }
    
    private fun executeGetWeather(params: Map<String, Any>): FunctionResult {
        val city = params["city"] as String
        
        // Mock weather data
        val weather = WeatherInfo(
            city = city,
            temperature = (15..30).random(),
            condition = listOf("Sunny", "Cloudy", "Rainy").random(),
            humidity = (40..80).random()
        )
        
        return FunctionResult(
            functionName = "get_weather",
            data = weather,
            summary = "üå§Ô∏è ${weather.city}: ${weather.temperature}¬∞C, ${weather.condition}"
        )
    }
}

// Data Classes
data class FunctionResult(
    val functionName: String,
    val data: Any,
    val summary: String,
    val timestamp: Long = System.currentTimeMillis()
)

data class Note(
    val id: String,
    val title: String,
    val content: String,
    val userId: String,
    val timestamp: Long
)

data class WeatherInfo(
    val city: String,
    val temperature: Int,
    val condition: String,
    val humidity: Int
)