package com.example.app.repository

import com.example.app.ai.AIService
import com.example.app.backend.FirebaseBackend
import com.example.app.data.local.AppDatabase
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Repository Pattern - Clean Architecture
 * Auto-generated by CodeCraft AI
 */

@Singleton
class AIRepository @Inject constructor(
    private val aiService: AIService,
    private val localDb: AppDatabase
) {
    
    /**
     * Streaming AI Response
     */
    fun generateTextStream(prompt: String): Flow<String> = flow {
        val fullResponse = StringBuilder()
        
        // Simulate streaming (real implementation would use SSE)
        val result = aiService.generateText(prompt).getOrNull()
        result?.let { response ->
            response.chunked(10).forEach { chunk ->
                fullResponse.append(chunk)
                emit(fullResponse.toString())
                kotlinx.coroutines.delay(100) // Simulate streaming delay
            }
        }
    }
    
    /**
     * Smart Prompt Templates
     */
    suspend fun generateWithTemplate(type: PromptType, content: String): Result<String> {
        val systemPrompt = when (type) {
            PromptType.SUMMARIZE -> "Sen profesyonel bir editörsün. Şu metni 3 maddede özetle: $content"
            PromptType.TRANSLATE -> "Sen uzman bir çevirmensin. Bu metni Türkçe'ye çevir: $content"
            PromptType.CODE_REVIEW -> "Sen senior bir geliştiricsin. Bu kodu analiz et ve öneriler ver: $content"
            PromptType.CREATIVE -> "Sen yaratıcı bir yazarsın. Bu konuda ilginç bir hikaye yaz: $content"
        }
        
        return aiService.generateText(systemPrompt)
    }
}

@Singleton
class DataRepository @Inject constructor(
    private val backend: FirebaseBackend,
    private val localDb: AppDatabase
) {
    
    /**
     * Offline-First Pattern
     */
    suspend fun <T> getData(collection: String, clazz: Class<T>): Flow<List<T>> = flow {
        // 1. Emit cached data first
        val cachedData = localDb.getCachedData(collection, clazz)
        emit(cachedData)
        
        // 2. Fetch from backend
        backend.getCollection(collection, clazz).onSuccess { remoteData ->
            // 3. Update cache
            localDb.cacheData(collection, remoteData)
            // 4. Emit fresh data
            emit(remoteData)
        }
    }
    
    /**
     * Smart Sync
     */
    suspend fun <T> saveData(collection: String, id: String, data: T): Result<Unit> {
        return try {
            // Save locally first
            localDb.saveData(collection, id, data)
            
            // Sync to backend
            backend.saveData(collection, id, data).onFailure {
                // Mark for retry
                localDb.markForSync(collection, id)
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

enum class PromptType {
    SUMMARIZE, TRANSLATE, CODE_REVIEW, CREATIVE
}